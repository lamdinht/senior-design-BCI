
streams = load_xdf( "E:\Villanova\human-brain-interface\senior-design-BCI\Dataset\Audrey_9_26\sub-P001\ses-S003 - eyes closed push\eeg\" + ...
                    "sub-P001_ses-S003 - eyes closed push_task-Default_run-001_eeg.xdf");

eeg_time_series = [];
eeg_time_stamps = [];


marker_time_series = [];
marker_time_stamps = [];


%% COMBINE TIME STREAMS
for i = 1:size(streams,2)
    if strcmp(streams{i}.info.type ,'EEG')
        eeg_time_series = [eeg_time_series streams{i}.time_series];
        eeg_time_stamps = [eeg_time_stamps streams{i}.time_stamps];
    end

    if strcmp(streams{i}.info.type, 'Markers')
       marker_time_series = [marker_time_series streams{i}.time_series];
       marker_time_stamps = [marker_time_stamps streams{i}.time_stamps];
    end
end

marker_time_stamps = marker_time_stamps - marker_time_stamps(1);
eeg_time_stamps = eeg_time_stamps - eeg_time_stamps(1);


% Variables (assumed to be given):
% eeg_time_stamps: an array of size (1, n) (time points for each sample)
% eeg_time_series: an array of size (channels, n) (EEG data for each channel)
% marker_time_stamps: an array of size (1, m)
% marker_time_series: a cell array of size (1, m) (markers for events)

% Prompt the user to input whether 'resting' or 'focusing' starts first
starting_state = input('Enter starting state (resting or focusing): ', 's');

% Predefine output structure
output = [];

% Initialize the segment counter and state alternation
segment_counter = 1;
current_state = starting_state;

% Loop through the marker_time_series
for i = 1:length(marker_time_series)
    % Check if the current marker contains 'released'
    if contains(marker_time_series{i}, 'released')

        % If i is the last marker, stop to avoid out-of-bounds error
        if i == length(marker_time_series)
            disp('Reached the last marker, stopping...');
            break;
        end

        % Get time_start and time_stop
        time_start = marker_time_stamps(i);  % When recording starts
        time_stop = marker_time_stamps(i+1); % When recording stops

        % Get the indexes of the EEG time stamps within this range
        eeg_indexes = find(eeg_time_stamps > time_start & eeg_time_stamps < time_stop);
        
        % If there are valid indexes, proceed
        if ~isempty(eeg_indexes)
            % Get the time stamps for the segment
            segment_time_stamps = eeg_time_stamps(eeg_indexes);
            
            % Get the corresponding EEG data for all channels
            segment_eeg_data = eeg_time_series(:, eeg_indexes);

            % Concatenate time stamps as the first row and EEG data below
            output = [segment_time_stamps; segment_eeg_data];

            % Determine the current state for naming
            if strcmpi(current_state, 'resting')
                prefix = 'Resting_';
            elseif strcmpi(current_state, 'focusing')
                prefix = 'Focusing_';
            else
                error('Invalid starting state. Must be "resting" or "focusing".');
            end

            % Create the CSV filename for this segment
            filename = [prefix num2str(segment_counter) '.csv'];

            % Write the output to CSV
            csvwrite(filename, output);

            % Increment the segment counter for the next segment
            segment_counter = segment_counter + 1;

            % Toggle the current state for the next segment
            if strcmpi(current_state, 'resting')
                current_state = 'focusing';
            else
                current_state = 'resting';
            end
        end
    end
end



%% Preliminary Process:
%    - Recenter signal: subtracting mean from array
%    - Reject powerline: notch from 59.9 to 60.1hz

%    - Plot fft and time series of all bands
%    - Recenter data by subtracting the average, plot fft and time series
%    - Focus on 0 to 20Hz on another graph

% BANDPASS FILTER
% fs = 256;
% x1=eeg_time_series(2,:);
% upper_freq_limit=20;
% lower_freq_limit=1;
% x = bandpass(x1,[lower_freq_limit upper_freq_limit],fs);
% 
% HIGHPASS FILTER
% fs = 256;
% x1=eeg_time_series(2,:);
% upper_freq_limit=20;
% x = highpass(x1,upper_freq_limit,fs);

% Select Channel:
%     eeg_time_series(1,:): AF7
%     eeg_time_series(2,:): TP9
%     eeg_time_series(3,:): TP10
%     eeg_time_series(4,:): AF8
for i = 1:4
    x1 = eeg_time_series(i,:);
    N = length(x1);
    fs = 256;
    
    % Preprocess data:
    % - Recenter signal: subtracting mean from array
    % - Reject powerline: notch from 59.9 to 60.1hz
    x1 = x1 - sum(x1)/size(x1,2);
    x1 = bandstop(x1,[59.9, 60.1],fs);
    f = [0:fs/N:fs];
    f = f(1:end-1);
    subplot(4,2,i*2-1);
    plot(f,abs(fft(x1)));
    
    % Frequency Density
    xdft = fft(x1);
    xdft = xdft(1:N/2+1);
    psdx = (1/(fs*N)) * abs(xdft).^2;
    psdx(2:end-1) = 2*psdx(2:end-1);
    freq = 0:fs/length(x1):fs/2;
    show_limit=fs/2; % Enter the freq want to show
    freq_n=freq(freq<=show_limit);
    psdx_n=psdx(freq<=show_limit);
    plot(freq_n,pow2db(psdx_n),'LineWidth', 0.05);
    grid on
    title("Periodogram Using FFT")
    xlabel("Frequency (Hz)")
    ylabel("Power/Frequency (dB/Hz)")

    % Lowpass Filter
    fs = 256;
    lower_freq_limit=20;
    x1 = lowpass(x1,lower_freq_limit,fs);

    % Frequency Density After Lowpass
    xdft = fft(x1);
    xdft = xdft(1:N/2+1);
    psdx = (1/(fs*N)) * abs(xdft).^2;
    psdx(2:end-1) = 2*psdx(2:end-1);
    freq = 0:fs/length(x1):fs/2;
    show_limit=20; % Enter the freq want to show
    freq_n=freq(freq<=show_limit);
    psdx_n=psdx(freq<=show_limit);
    subplot(4,2,i*2);
    plot(freq_n,pow2db(psdx_n))
    
    grid on
    title("Periodogram Using FFT")
    xlabel("Frequency (Hz)")
    ylabel("Power/Frequency (dB/Hz)")
end

%% PROCESS DATA FROM CSV
fs = 256;
import_csv = true;
csv_file = "A1Push";

% Step 1: Import the CSV file
if import_csv
    data = csvread(csv_file + ".csv"); 
end

% Step 2: Separate the timestamps and EEG time series
timestamps = data(1, :);           % 1st row contains timestamps
eeg_time_series = data(2:end-1, :); % 2nd row onwards are EEG channels, drop the final line

% Step 3: Normalize the timestamps (subtract the first value)
timestamps = timestamps - timestamps(1);

% Step 4: Determine subplot size (2 columns by number of channels)
figure;
num_channels = size(eeg_time_series, 1);
num_subplots = num_channels * 2;  % Two subplots per channel (time series and PSD)
set(gcf, 'Position', get(0, 'Screensize'));  % Maximize figure window

% Step 5: Initialize output for wave powers
output_band_powers = [];

% Step 6: Loop through each EEG channel
for ch = 1:num_channels
    % Step 6a: Extract the current channel's data
    eeg_channel_data = eeg_time_series(ch, :);
    
    % Step 6b: Apply filters (lowpass, highpass, notch)
    % Lowpass @0.5Hz
    eeg_filtered = highpass(eeg_channel_data, 0.5, fs);  % 'fs' is the sampling frequency
    
    % Highpass @100Hz
    eeg_filtered = lowpass(eeg_filtered, 40, fs);
    
    % Notch filter from 59.9Hz to 60.1Hz
    d = designfilt('bandstopiir', 'FilterOrder', 2, ...
                   'HalfPowerFrequency1', 59.9, 'HalfPowerFrequency2', 60.1, ...
                   'DesignMethod', 'butter', 'SampleRate', fs);
    
    % Apply the notch filter to remove 60Hz power line noise
    eeg_filtered = filtfilt(d, eeg_filtered);
    
    % Step 6c: Perform FFT on the filtered channel
    eeg_fft = fft(eeg_filtered);
    
    % Step 6d: Plot the time series in the left subplot
    subplot(num_channels, 2, (ch-1)*2 + 1);
    plot(timestamps, eeg_filtered);
    title(['Time Series - Channel ' num2str(ch)]);
    xlabel('Time (s)');
    ylabel('Amplitude');
    
    % Step 6e: Calculate and plot the power spectral density (PSD) on the right subplot
    subplot(num_channels, 2, (ch-1)*2 + 2);
    [psd_data, f] = pwelch(eeg_filtered, [], [], [], fs); % PSD using Welch's method
    plot(f, 10*log10(psd_data));
    title(['PSD - Channel ' num2str(ch)]);
    xlabel('Frequency (Hz)');
    ylabel('Power/Frequency (dB/Hz)');
    
    % Step 6f: Calculate band powers (delta, theta, alpha, beta, gamma)
    delta_power = bandpower(psd_data, f, [0.5 4], 'psd');
    theta_power = bandpower(psd_data, f, [4 8], 'psd');
    alpha_power = bandpower(psd_data, f, [8 13], 'psd');
    beta_power = bandpower(psd_data, f, [13 30], 'psd');
    gamma_power = bandpower(psd_data, f, [30 100], 'psd');
    
    % Append the band powers to the output
    output_band_powers = [output_band_powers; delta_power, theta_power, alpha_power, beta_power, gamma_power];
end

saveas(gcf, filename + ".png");

% Step 7: Prepare the data for appending
output_table = [(1:num_channels)', output_band_powers]; % Channel numbers and band powers

% Step 8: Check if the file exists, and either append or create the file
filename = 'band_powers_output.csv';
if isfile(filename)
    % File exists, so append the new data
    dlmwrite(filename, output_table, '-append');
else
    % File does not exist, create the file and write header and data
    csv_header = {'Channel', 'Delta Power (0.5-4 Hz)', 'Theta Power (4-8 Hz)', ...
                  'Alpha Power (8-13 Hz)', 'Beta Power (13-30 Hz)', 'Gamma Power (30-100 Hz)'};
    fid = fopen(filename, 'w');
    fprintf(fid, '%s,%s,%s,%s,%s,%s\n', csv_header{:});  % Write header
    fclose(fid);
    dlmwrite(filename, output_table, '-append');
end

%% PARSE CSV FOR NN TRAINING

% Load the dataset from CSV file
filename = 'A2Push.csv'; % Replace with the actual file name
data = readtable(filename); % Read the CSV file into a table

% Extract timestamps and EEG data (assuming columns: time, EEG1, EEG2, EEG3, EEG4)
timestamps = data{:, 1}; % Assuming first column is time
eeg_data = data{:, 2:5}; % Assuming next four columns are EEG channels

% Read the counter from a text file
counter_file = 'counter.txt';
if exist(counter_file, 'file')
    fid = fopen(counter_file, 'r');
    counter = fscanf(fid, '%d');
    fclose(fid);
else
    % If the file doesn't exist, initialize the counter at 1
    counter = 1;
end

% Parameters
time_step = 0.2; % Step size of 0.2 seconds
window_size = 1; % Analyze in 1-second windows

% Create folder for training data if it does not exist
if ~exist('training', 'dir')
    mkdir('training');
end

% Iterate over timestamps with step size of 0.2s
for t = min(timestamps):time_step:(max(timestamps)-window_size)
    
    % Get the data in the time window [t to t+1]
    section_indices = (timestamps >= t & timestamps < t + window_size);
    section_data = eeg_data(section_indices, :);
    section_timestamps = timestamps(section_indices);
    
    % Name and save the data in the training folder
    training_filename = sprintf('training/%s_%d.csv', filename, counter);
    writetable(array2table([section_timestamps, section_data]), training_filename);
    
    % Increment the counter for the next file
    counter = counter + 1;
    
    % Save the updated counter back to the text file
    fid = fopen(counter_file, 'w');
    fprintf(fid, '%d', counter);
    fclose(fid);
end

disp('Processing complete!');
